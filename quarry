-- Dar Quarry by Darganis
-- version: 0.0.2 9/3/2012

local m = dagsAPI.Move.new()
local a = dagsAPI.Action.new()
local u = dagsAPI.Utils.new()

local params = { ... }

if #params == 1 then

  length  = tonumber(params[1])

else

  term.clear()
  term.setCursorPos(1,1)
  term.write("Radius of quarry? ")
  length = tonumber(read())

end

-- set the width to length
width = length
-- Coordinates
curCords = {}
curCords["xcord"] = 0
curCords["ycord"] = 0
curCords["zcord"] = 0
savedCords = {}
savedCords["xcord"] = 0
savedCords["ycord"] = 0
savedCords["zcord"] = 0
-- Direction
direction = 1

print("")

function refuel()
  if turtle.getFuelLevel() < 5 then
    print("Refueling...")
    shell.run("refuel", 5)
  end
end

function pillar()
  local output = true
  output1 = doDigFront()
  goForward(1)
  output2 = doDigDown()
  output3 = doDigUp()
  return ( output1 and output2 and output3 )
end

function row(width)
  local curWidth = 0
  while curWidth < width do
    output = pillar()
    curWidth = curWidth + 1
  end
  return output, curWidth
end

function level(rows)
  local side
  local output1 = false
  local output2 = false
  local curLength = 0
  local curWidth = 0
  -- repeat levels till can move down
  for i=1,rows do
    if i%2 == 0 then
      side = 4
    else
      side = 2
    end
    if i == 1 then
      turnToDir(2)
      output2, curWidth = row(width-1)
    else
      turnToDir(1)
      output1 = pillar()
      turnToDir(side)
      output2, curWidth = row(width-1)
    end
    curLength = curLength + 1
  end
  levelReturnToStart(curLength,curWidth)
end

function goNextLevel()
  doDigDown()
  output = goDown(1)
  doDigDown()
  output = goDown(1)
  doDigDown()
  return output
end

function levelReturnToStart( length, width )
  if curCords["xcord"] == 0 then
    turnToDir(3)
  else
    turnToDir(4)
    goForward(width)
    turnToDir(3)
  end
  goForward(length-1)
  goDown(1)
end

function returnToStart( length, width )
  saveCords()
  goTo( 0, 0, 0 )
  turnToDir(3)
end

function doDropOff()
  local isFull
  local count
  -- test inventory
  for i=1,16 do
    turtle.select(i)
    count = turtle.getItemCount(i)
    if count == 0 then
      isFull = false
      break
    else
      isFull = true
    end
  end
  turtle.select(1)
  -- goTo start if isFull and come back
  if isFull then
    returnToStart()
    emptyInvemtory()
    turnToDir(1)
    goForward(1)
    goTo( savedCords["xcord"], savedCords["ycord"], savedCords["zcord"] )
  end
end

function emptyInvemtory()
  for i=1,16 do
    turtle.select(i)
    turtle.drop()
  end
end

function quarry()
  refuel()
  if turtle.getFuelLevel() == 0 then
    print("I am out of fuel. Please give me fuel and try again.")
    return
  end
  doDigFront()
  goForward(1)
  goNextLevel()
  repeat
    level(math.abs(length - curCords["xcord"]))
  until not goNextLevel()
end

-- Utility Functions

function saveCords()
  savedCords["xcord"] = curCords["xcord"]
  savedCords["ycord"] = curCords["ycord"]
  savedCords["zcord"] = curCords["zcord"]
end

function goTo( x, y, z )
  repeat
    a.digUp()
  until not turtle.detectUp()
  -- deal with Y cord
  disty = math.abs( y - curCords["ycord"] )
  if (y < curCords["ycord"]) then
    goDown(disty)
  else
    goUp(disty)
  end
  -- deal with X cord
  distx = x - curCords["xcord"]
  if (x > curCords["xcord"]) then
    turnToDir(2)
  else
    turnToDir(4)
  end
  distx = math.abs(distx)
  goForward(distx)
  -- deal with Z cord
  distz = z - curCords["zcord"]
  if (z > curCords["zcord"]) then
    turnToDir(1)
  else
    turnToDir(3)
  end
  distz = math.abs(distz)
  goForward(distz)
end

function goForward( times )
  local succeed, count = m.forward(times)
  if direction == 1 then
    curCords["zcord"] = curCords["zcord"] + count
  elseif direction == 2 then
    curCords["xcord"] = curCords["xcord"] + count
  elseif direction == 3 then
    curCords["zcord"] = curCords["zcord"] - count
  elseif direction == 4 then
    curCords["xcord"] = curCords["xcord"] - count
  end
  printStats()
  return succeed
end

function goDown( times )
  local succeed, count = m.down(times)
  curCords["ycord"] = curCords["ycord"] - count
  printStats()
  return succeed
end

function goUp( times )
  local succeed, count = m.up(times)
  curCords["ycord"] = curCords["ycord"] + count
  printStats()
  return succeed
end

function doDigUp()
  doDropOff()
  a.digUp()
end

function doDigDown()
  doDropOff()
  a.digDown()
end

function doDigFront()
  doDropOff()
  a.digFront()
end

function turnToDir( toDir )
  local times = math.abs(direction - toDir)
  local turnTo
  if direction < toDir and times < 3 then
    turnTo = "right"
  elseif direction > toDir and times == 3 then
    turnTo = "right"
  else
    turnTo = "left"
  end
  if times == 3 then
    m.turn(turnTo, 1)
  else
    m.turn(turnTo, times)
  end
  direction = toDir
  printStats()
end

function printStats()
  term.clear()
  term.setCursorPos(1,1)
  print("xcord = "..curCords["xcord"])
  print("ycord = "..curCords["ycord"])
  print("zcord = "..curCords["zcord"])
  print("saved xcord = "..savedCords["xcord"])
  print("saved ycord = "..savedCords["ycord"])
  print("saved zcord = "..savedCords["zcord"])
  print("direction = "..direction)
end

-- pause to close screen
sleep(2)
quarry()