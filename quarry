-- Dar Quarry by Darganis
-- version: 0.0.2 9/3/2012

local m = dagsAPI.Move.new()
local a = dagsAPI.Action.new()
local u = dagsAPI.Utils.new()

local params = { ... }

if #params == 1 then

  length  = tonumber(params[1])

else

  term.clear()
  term.setCursorPos(1,1)
  term.write("Radius of quarry? ")
  length = tonumber(read())

end

-- set the width to length
width = length
-- Coordinates
xcord = 0
ycord = 0
zcord = 0
-- Direction
direction = 1

print("")

function refuel()
  if turtle.getFuelLevel() < 5 then
    print("Refueling...")
    shell.run("refuel", 5)
  end
end

function pillar()
  local output = true
  output1 = a.digFront()
  goForward(1)
  output2 = a.digDown()
  output3 = a.digUp()
  return ( output1 and output2 and output3 )
end

function row(width)
  local curWidth = 0
  while curWidth < width do
    output = pillar()
    curWidth = curWidth + 1
  end
  return output, curWidth
end

function level(rows)
  local side
  local output1 = false
  local output2 = false
  local curLength = 0
  local curWidth = 0
  -- repeat levels till can move down
  for i=1,rows do
    if i%2 == 0 then
      side = 4
    else
      side = 2
    end
    if i == 1 then
      turnToDir(2)
      output2, curWidth = row(width-1)
    else
      turnToDir(1)
      output1 = pillar()
      turnToDir(side)
      output2, curWidth = row(width-1)
    end
    curLength = curLength + 1
  end
  levelReturnToStart(curLength,curWidth)
end

function goNextLevel()
  a.digDown()
  output = goDown(1)
  a.digDown()
  output = goDown(1)
  a.digDown()
  return output
end

function levelReturnToStart( length, width )
  if xcord == 0 then
    turnToDir(3)
  else
    turnToDir(4)
    goForward(width)
    turnToDir(3)
  end
  goForward(length-1)
  goDown(1)
end

function quarry()
  refuel()
  if turtle.getFuelLevel() == 0 then
    print("I am out of fuel. Please give me fuel and try again.")
    return
  end
  a.digFront()
  goForward(1)
  goNextLevel()
  repeat
    level()
  until not goNextLevel()
end

-- Utility Functions

function goTo( x, y, z )
  repeat
    a.digUp()
  until not turtle.detectUp()
  -- deal with Y cord
  disty = math.abs( y - ycord )
  if (y < ycord) then
    goDown(disty)
  else
    goUp(disty)
  end
  -- deal with X cord
  distx = x - xcord
  if (x > xcord) then
    turnToDir(2)
  else
    turnToDir(4)
  end
  distx = math.abs(distx)
  goForward(distx)
  -- deal with Z cord
  distz = z - zcord
  if (z > zcord) then
    turnToDir(1)
  else
    turnToDir(3)
  end
  distz = math.abs(distz)
  goForward(distz)
end

function goForward( times )
  local succeed, count = m.forward(times)
  if direction == 1 then
    zcord = zcord + count
  elseif direction == 2 then
    xcord = xcord + count
  elseif direction == 3 then
    zcord = zcord - count
  elseif direction == 4 then
    xcord = xcord - count
  end
  printStats()
  return succeed
end

function goDown( times )
  local succeed, count = m.down(times)
  ycord = ycord - count
  printStats()
  return succeed
end

function goUp( times )
  local succeed, count = m.up(times)
  ycord = ycord + count
  printStats()
  return succeed
end

function turnToDir( toDir )
  local times = math.abs(direction - toDir)
  local turnTo
  if direction < toDir and times < 3 then
    turnTo = "right"
  elseif direction > toDir and times == 3 then
    turnTo = "right"
  else
    turnTo = "left"
  end
  if times == 3 then
    m.turn(turnTo, 1)
  else
    m.turn(turnTo, times)
  end
  direction = toDir
  printStats()
end

function printStats()
  term.clear()
  term.setCursorPos(1,1)
  print("xcord = "..xcord)
  print("ycord = "..ycord)
  print("zcord = "..zcord)
  print("direction = "..direction)
end

-- pause to close screen
sleep(2)
quarry()